<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>State machine - Sequential Workflow Designer</title>

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

	<script src="../designer.js"></script>
	<link href="../designer.css" rel="stylesheet">

	<style>
		body, input, button {font: 14px/1.3em 'Open Sans', Arial, Verdana, Serif;}
		html, body {width: 100vw; height: 100vh; margin: 0; padding: 0; overflow: hidden;}

		#designer {position: absolute; left: 0; top: 0; width: 70vw; height: 100vh;}
		.sqd-global-editor, .sqd-step-editor {padding: 10px;}
		.sqd-smart-editor p {margin: 0; padding: 0 0 10px;}
		.sqd-smart-editor label {display: block; padding: 0 0 10px;}
		.sqd-smart-editor input[type=text] {width: 100%; box-sizing: border-box; border: 1px solid silver; padding: 6px; border-radius: 5px;}

		#result {position: absolute; right: 0; bottom: 0; width: 30vw; height: 100vh; padding: 10px; box-sizing: border-box; color: #FFF; background: #2C18DF;}
		#result button {padding: 10px; color: #000; background: #FFF; border: 0; border-radius: 5px; cursor: pointer;}
		#result button:hover {opacity: 0.8;}
	</style>
</head>
<body>
	<div id="designer"></div>

	<div id="result">
		<button id="run">Run state machine ðŸš€</button>

		<h5>State</h5>

		<pre id="state"></pre>

		<h5>Console</h5>

		<pre id="console"></pre>
	</div>

	<script>
		let designer;

		function uid() {
			return Math.ceil(Math.random() * 10**16).toString(16);
		}

		function createMathStep(type, name, varName, val) {
			return {
				id: uid(),
				componentType: 'task',
				type,
				name,
				properties: {
					var: varName,
					val
				}
			};
		}

		function createTextStep(message) {
			return {
				id: uid(),
				componentType: 'task',
				type: 'text',
				name: message,
				properties: {
					text: message
				}
			};
		}

		function createIfStep(varName, val, name, trueSteps, falseSteps) {
			return {
				id: uid(),
				componentType: 'switch',
				type: 'if',
				name,
				branches: {
					'true': trueSteps || [],
					'false': falseSteps || []
				},
				properties: {
					var: varName,
					val
				}
			};
		}

		function createLoopStep(varName, val, name, steps) {
			return {
				id: uid(),
				componentType: 'container',
				type: 'loop',
				name,
				sequence: steps || [],
				properties: {
					var: varName,
					val
				}
			};
		}

		function appendTitle(parent, text) {
			const title = document.createElement('h4');
			title.innerText = text;
			parent.appendChild(title);
		}

		function appendTextField(parent, label, startValue, set) {
			const field = document.createElement('p');
			parent.appendChild(field);
			field.innerHTML = `<label></label> <input type="text">`;
			field.querySelector('label').innerText = label;
			const input = field.querySelector('input');
			input.value = startValue;
			field.addEventListener('input', () => set(input.value));
		}

		function createVariableIfNeeded(varName, state) {
			if (!state.vars[varName]) {
				state.vars[varName] = 0;
			}
		}

		function executeMathStep(step, state) {
			const varName = step.properties['var'];
			const value = step.properties['val'];
			createVariableIfNeeded(varName, state);
			switch (step.type) {
				case 'add':
					state.vars[varName] += value;
					break;
				case 'sub':
					state.vars[varName] -= value;
					break;
				case 'mul':
					state.vars[varName] *= value;
					break;
				case 'div':
					state.vars[varName] /= value;
					break;
			}
		}

		function unwindStack(state) {
			state.callstack.pop();
		}

		function executeIfStep(step, state) {
			var varName = step.properties['var'];
			createVariableIfNeeded(varName, state);
			const branchName = (state.vars[varName] > step.properties['val'])
				? 'true'
				: 'false';

			state.callstack.push({
				sequence: step.branches[branchName],
				index: 0,
				unwind: unwindStack
			});
		}

		function executeLoopStep(step, state) {
			const varName = step.properties['var'];
			state.vars[varName] = step.properties['val'];

			const program = {
				sequence: step.sequence,
				index: 0,
				unwind: () => {
					if (state.vars[varName] > 0) {
						program.index = 0;
						state.vars[varName]--;
					} else {
						unwindStack(state);
					}
				}
			};
			state.callstack.push(program);
		}

		function printState(state) {
			document.getElementById('state').innerText = JSON.stringify({
				stepIndex: state.stepIndex,
				vars: state.vars
			}, null, 2);
		}

		function clearConsole() {
			document.getElementById('console').innerText = '';
		}

		function printText(message) {
			const time = (new Date()).toLocaleTimeString();
			document.getElementById('console').innerText += `<${time}> ${message}\r\n`;
		}

		function run() {
			if (designer.isReadonly()) {
				return;
			}
			clearConsole();

			const definition = designer.getDefinition();
			designer.setIsReadonly(true);

			const speed = definition.properties['speed'];
			const state = {
				callstack: [
					{
						sequence: definition.sequence,
						index: 0,
						unwind: null
					}
				],
				vars: {}
			};

			function tick() {
				const depth = state.callstack.length - 1;
				const program = state.callstack[depth];

				if (program.sequence.length === program.index) {
					if (depth > 0) {
						program.unwind(state);
						tick();
					} else {
						designer.setIsReadonly(false);
						designer.clearSelectedStep();
					}
					return;
				}

				const step = program.sequence[program.index];
				program.index++;

				switch (step.type) {
					case 'add':
					case 'sub':
					case 'div':
					case 'mul':
						executeMathStep(step, state);
						break;
					case 'text':
						printText(step.properties['text']);
						break;
					case 'if':
						executeIfStep(step, state);
						break;
					case 'loop':
						executeLoopStep(step, state);
						break;
				}

				designer.selectStepById(step.id);
				designer.moveViewPortToStep(step.id);
				printState(state);
				setTimeout(tick, speed);
			}

			tick();
		}

		const configuration = {
			toolbox: {
				isHidden: false,
				groups: [
					{
						name: 'Tasks',
						steps: [
							createMathStep('add', 'Add', 'x', 10),
							createMathStep('sub', 'Subtract', 'x', 10),
							createMathStep('mul', 'Multiply', 'x', 10),
							createMathStep('div', 'Divide', 'x', 10),
							createTextStep('Message!')
						]
					},
					{
						name: 'Logic',
						steps: [
							createIfStep('x', 10, 'If'),
							createLoopStep('index', 3, 'Loop')
						]
					}
				]
			},

			steps: {
				iconUrlProvider: (componentType, type) => {
					const supportedIcons = ['if', 'loop', 'text'];
					const fileName = supportedIcons.includes(type) ? type : 'task';
					return `./assets/icon-${fileName}.svg`;
				},

				validator: (step) => {
					return Object.keys(step.properties).every(n => !!step.properties[n]);
				}
			},

			editors: {
				globalEditorProvider: (definition) => {
					const container = document.createElement('span');
					appendTitle(container, 'State machine config');
					appendTextField(container, 'Speed (ms)', definition.properties['speed'],
							v => definition.properties['speed'] = parseInt(v, 10));
					return container;
				},
				stepEditorProvider: (step) => {
					const container = document.createElement('div');
					appendTitle(container, 'Step ' + step.type);

					appendTextField(container, 'Name', step.name,
						v => {
							step.name = v;
							designer.notifiyDefinitionChanged();
						});
					if (step.properties['var'] !== undefined) {
						appendTextField(container, 'Variable', step.properties['var'],
							v => {
								step.properties['var'] = v;
								designer.revalidate();
							});
					}
					if (step.properties['val']) {
						appendTextField(container, 'Value', step.properties['val'],
							v => {
								step.properties['val'] = parseInt(v, 10);
								designer.revalidate();
							});
					}
					if (step.properties['text']) {
						appendTextField(container, 'Text', step.properties['text'],
							v => {
								step.properties['text'] = v;
								designer.revalidate();
							});
					}
					return container;
				}
			}
		};

		const startDefinition = {
			properties: {
				speed: 300
			},
			sequence: [
				createTextStep('start!'),
				createLoopStep('index', 4, 'Loop', [
					createMathStep('add', 'x += 3', 'x', 3),
					createMathStep('mul', 'x *= 2', 'x', 2),
					createIfStep('x', 50, 'If x > 50',
						[ createTextStep('yes!') ],
						[ createTextStep('no...')]),
				]),
				createTextStep('the end')
			]
		};
		const placeholder = document.getElementById('designer');
		designer = sequentialWorkflowDesigner.create(placeholder, startDefinition, configuration);
		document.getElementById('run').addEventListener('click', run);
	</script>
</body>
</html>
